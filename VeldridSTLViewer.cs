//using System;
//using System.IO;
//using System.Numerics;
//using Veldrid;
//using Veldrid.Sdl2;
//using Veldrid.StartupUtilities;
//using Veldrid.SPIRV;
//using System.Text;
//using System.Runtime.InteropServices;
//using System.Reflection;

//namespace VeldridSTLViewer
//{



//    public enum SDL_bool
//    {
//        SDL_FALSE = 0,
//        SDL_TRUE = 1
//    }

//    public static class SDL2Native
//    {
//        [DllImport("SDL2", CallingConvention = CallingConvention.Cdecl)]
//        public static extern int SDL_SetRelativeMouseMode(SDL_bool enabled);

//        [DllImport("SDL2", CallingConvention = CallingConvention.Cdecl)]
//        public static extern int SDL_GetRelativeMouseState(out int x, out int y);

//        [DllImport("SDL2", CallingConvention = CallingConvention.Cdecl)]
//        public static extern int SDL_GetMouseState(out int x, out int y);

//        [DllImport("SDL2", CallingConvention = CallingConvention.Cdecl)]
//        public static extern void SDL_WarpMouseInWindow(IntPtr window, int x, int y);
//    }


//    class VeldridSTLViewer
//    {
//        Graphics and rendering objects:
//        private static GraphicsDevice _graphicsDevice;
//        private static CommandList _commandList;
//        private static DeviceBuffer _vertexBuffer;
//        private static DeviceBuffer _indexBuffer;
//        private static Shader[] _shaders;
//        private static Pipeline _pipeline;

//        private static DeviceBuffer _mvpBuffer;
//        private static ResourceLayout _mvpLayout;
//        private static ResourceSet _mvpResourceSet;
//        private static Sdl2Window _window; // For window events and dimensions
//        private static Framebuffer _framebuffer;
//        private static Matrix4x4 _modelMatrix;

//        Orbit camera parameters:
//         _yaw controls horizontal rotation(unbounded).
//        private static float _yaw = 0f;
//        _verticalOffset controls the camera's height relative to the object.
//        private static float _verticalOffset = 0f;
//        We'll clamp _verticalOffset between -2 and 2.

//         For warping-based mouse control:
//        private static int _centerX, _centerY;
//        Flag to ignore the MouseMove event generated by warping.
//        private static bool _ignoreNextMouseMove = false;
//        Drag flag.
//        private static bool _isDragging = false;

//        Sensitivity multipliers:
//        private const float SensitivityX = 0.0020f;
//        private const float SensitivityY = 0.0020f;

//        private const string VertexCode = @"
// #version 450
// layout(location = 0) in vec3 Position;
// layout(location = 1) in vec3 Normal;
// layout(location = 0) out vec3 v_Normal;
// layout(set = 0, binding = 0) uniform MVP
// {
//     mat4 Model;
//     mat4 View;
//     mat4 Projection;
// };
// void main()
// {
//     gl_Position = Projection * View * Model * vec4(Position, 1.0);
//     v_Normal = mat3(Model) * Normal;
// }";

//        private const string FragmentCode = @"
// #version 450
// layout(location = 0) in vec3 v_Normal;
// layout(location = 0) out vec4 fsout_Color;
// void main()
// {
//     vec3 lightDir = normalize(vec3(0.5, 1.0, 0.5));
//     float brightness = max(dot(normalize(v_Normal), lightDir), 0.2);
//     fsout_Color = vec4(vec3(brightness), 1.0);
// }";

//        Simple clamping helper for integers.
//        private static int ClampInt(int value, int min, int max)
//        {
//            if (value < min)
//                return min;
//            else if (value > max)
//                return max;
//            else
//                return value;
//        }

//        Simple clamping helper for floats.
//        private static float Clamp(float value, float min, float max)
//        {
//            if (value < min)
//                return min;
//            else if (value > max)
//                return max;
//            else
//                return value;
//        }

//        public void Run()
//        {
//            Console.WriteLine("Creating Window...");
//            WindowCreateInfo windowCI = new WindowCreateInfo()
//            {
//                X = 100,
//                Y = 100,
//                WindowWidth = 960,
//                WindowHeight = 540,
//                WindowTitle = "Veldrid Tutorial"
//            };
//            Sdl2Window window = VeldridStartup.CreateWindow(ref windowCI);
//            _window = window; // Save window reference

//            Determine the center of the window.
//            _centerX = _window.Width / 2;
//            _centerY = _window.Height / 2;

//            Mouse event subscriptions using absolute positions and warping:
//            _window.MouseDown += e =>
//            {
//                _isDragging = true;
//                 Warp the mouse to the center as the starting point.
//                IntPtr sdlWindowPtr = (IntPtr)typeof(Sdl2Window)
//    .GetField("_window", BindingFlags.Instance | BindingFlags.NonPublic)
//                    .GetValue(_window);
//    SDL2Native.SDL_WarpMouseInWindow(sdlWindowPtr, _centerX, _centerY);
//                _ignoreNextMouseMove = true;
//            };

//_window.MouseUp += e =>
//{
//    _isDragging = false;
//};

//_window.MouseMove += e =>
//{
//    if (_isDragging)
//    {
//        if (_ignoreNextMouseMove)
//        {
//            _ignoreNextMouseMove = false;
//            return;
//        }
//        int mouseX, mouseY;
//        SDL2Native.SDL_GetMouseState(out mouseX, out mouseY);
//        int dx = mouseX - _centerX;
//        int dy = mouseY - _centerY;
//        Clamp deltas to filter extreme values.

//        dx = ClampInt(dx, -200, 200);
//        dy = ClampInt(dy, -200, 200);
//        Update the orbit parameters:
//                     Horizontal movement(dx) rotates the camera(update _yaw).

//         Vertical movement(dy) moves the camera up/ down(update _verticalOffset).
//        _yaw += dx * SensitivityX;
//        _verticalOffset -= dy * SensitivityY;
//        Clamp vertical offset to keep the camera from moving too far.
//                   _verticalOffset = Clamp(_verticalOffset, -2.0f, 2.0f);
//        Warp the mouse back to the center.
//                   IntPtr sdlWindowPtr = (IntPtr)typeof(Sdl2Window)
//   .GetField("_window", BindingFlags.Instance | BindingFlags.NonPublic)
//                       .GetValue(_window);
//        SDL2Native.SDL_WarpMouseInWindow(sdlWindowPtr, _centerX, _centerY);
//        _ignoreNextMouseMove = true;
//    }
//};

//if (!window.Exists)
//{
//    Console.WriteLine("Error: Window failed to initialize.");
//    return;
//}
//Console.WriteLine("Window successfully created.");

//GraphicsDeviceOptions options = new GraphicsDeviceOptions
//{
//    PreferStandardClipSpaceYDirection = true,
//    PreferDepthRangeZeroToOne = true,
//    SyncToVerticalBlank = true,
//    ResourceBindingModel = ResourceBindingModel.Improved
//};

//try
//{
//    Console.WriteLine("Creating Graphics Device...");
//    _graphicsDevice = VeldridStartup.CreateGraphicsDevice(window, options, GraphicsBackend.Vulkan);
//    Console.WriteLine("Graphics Device created successfully.");
//}
//catch (Exception ex)
//{
//    Console.WriteLine($"Error creating graphics device: {ex.Message}");
//    return;
//}

//Console.WriteLine("Creating Resources...");
//CreateResources();
//UpdateMVP();
//Console.WriteLine("Resources Created.");

//In this approach, we do not enable relative mouse mode globally.
//            while (window.Exists)
//            {

//   window.PumpEvents();
//                if (window.Exists)
//                {
//    Draw();
//}
//}
//Console.WriteLine("Exiting...");
//DisposeResources();
//        }

//        private static void CreateResources()
//{
//    ResourceFactory factory = _graphicsDevice.ResourceFactory;

//    Load STL file.
//   var(stlVertices, stlIndices) = LoadSTL("model.stl");
//    Console.WriteLine($"Loaded {stlVertices.Length} vertices and {stlIndices.Length} indices.");

//    Compute a transformation to center and scale the model.
//   Matrix4x4 modelTransform = ComputeModelMatrix(stlVertices);
//    _modelMatrix = modelTransform;

//    Create Vertex Buffer.
//   BufferDescription vbDescription = new BufferDescription(
//       (uint)(stlVertices.Length * VertexPositionNormal.SizeInBytes),
//       BufferUsage.VertexBuffer);
//    _vertexBuffer = factory.CreateBuffer(vbDescription);
//    _graphicsDevice.UpdateBuffer(_vertexBuffer, 0, stlVertices);

//    Create Index Buffer.
//   BufferDescription ibDescription = new BufferDescription(
//       (uint)(stlIndices.Length * sizeof(ushort)),
//       BufferUsage.IndexBuffer);
//    _indexBuffer = factory.CreateBuffer(ibDescription);
//    _graphicsDevice.UpdateBuffer(_indexBuffer, 0, stlIndices);

//    Create MVP Uniform Buffer(3 matrices: Model, View, Projection).
//            uint mvpBufferSize = (uint)(3 * 16 * sizeof(float));
//    _mvpBuffer = factory.CreateBuffer(new BufferDescription(mvpBufferSize, BufferUsage.UniformBuffer | BufferUsage.Dynamic));

//    Create a ResourceLayout for the MVP uniform.
//   _mvpLayout = factory.CreateResourceLayout(new ResourceLayoutDescription(
//       new ResourceLayoutElementDescription("MVP", ResourceKind.UniformBuffer, ShaderStages.Vertex)));

//    Create a ResourceSet using the MVP buffer.
//   _mvpResourceSet = factory.CreateResourceSet(new ResourceSetDescription(_mvpLayout, _mvpBuffer));

//    Vertex Layout for Position(vec3) and Normal(vec3).

//   VertexLayoutDescription vertexLayout = new VertexLayoutDescription(
//       new VertexElementDescription("Position", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float3),
//       new VertexElementDescription("Normal", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float3));

//    Create shaders.

//   ShaderDescription vertexShaderDesc = new ShaderDescription(ShaderStages.Vertex, Encoding.UTF8.GetBytes(VertexCode), "main");
//    ShaderDescription fragmentShaderDesc = new ShaderDescription(ShaderStages.Fragment, Encoding.UTF8.GetBytes(FragmentCode), "main");
//    _shaders = factory.CreateFromSpirv(vertexShaderDesc, fragmentShaderDesc);

//    Create the Depth Texture and Custom Framebuffer.
//            uint fbWidth = _graphicsDevice.SwapchainFramebuffer.Width;
//    uint fbHeight = _graphicsDevice.SwapchainFramebuffer.Height;
//    Texture depthTexture = _graphicsDevice.ResourceFactory.CreateTexture(
//        TextureDescription.Texture2D(fbWidth, fbHeight, mipLevels: 1, arrayLayers: 1,
//                                       format: PixelFormat.R32_G32_B32_A32_UInt,
//                                       usage: TextureUsage.GenerateMipmaps));
//    _framebuffer = _graphicsDevice.ResourceFactory.CreateFramebuffer(new FramebufferDescription(depthTexture,
//                _graphicsDevice.SwapchainFramebuffer.ColorTargets[0].Target));

//    Create pipeline – note the ResourceLayouts now include our MVP layout.
//            GraphicsPipelineDescription pipelineDescription = new GraphicsPipelineDescription
//            {
//                BlendState = BlendStateDescription.SingleOverrideBlend,
//                RasterizerState = new RasterizerStateDescription(
//                    cullMode: FaceCullMode.Back,
//                    fillMode: PolygonFillMode.Solid,
//                    frontFace: FrontFace.Clockwise,
//                    depthClipEnabled: true,
//                    scissorTestEnabled: false),
//                PrimitiveTopology = PrimitiveTopology.TriangleList,
//                ResourceLayouts = new ResourceLayout[] { _mvpLayout },
//                ShaderSet = new ShaderSetDescription(new VertexLayoutDescription[] { vertexLayout }, _shaders),
//                Outputs = _graphicsDevice.SwapchainFramebuffer.OutputDescription
//            };
//    _pipeline = factory.CreateGraphicsPipeline(pipelineDescription);
//    _commandList = factory.CreateCommandList();
//}

//Compute a simple model matrix that centers and scales the model.
//        private static Matrix4x4 ComputeModelMatrix(VertexPositionNormal[] vertices)
//{
//    Vector3 min = new Vector3(float.MaxValue);
//    Vector3 max = new Vector3(float.MinValue);
//    foreach (var v in vertices)
//    {
//        min = Vector3.Min(min, v.Position);
//        max = Vector3.Max(max, v.Position);
//    }
//    Vector3 center = (min + max) / 2;
//    float modelSize = Vector3.Distance(min, max);
//    float desiredSize = 2.0f;
//    float scaleFactor = desiredSize / modelSize;
//    Matrix4x4 translation = Matrix4x4.CreateTranslation(-center);
//    Matrix4x4 scale = Matrix4x4.CreateScale(scaleFactor);
//    return translation * scale;
//}

//UpdateMVP computes the camera's view based on _yaw (horizontal rotation) and _verticalOffset.
//        private static void UpdateMVP()
//{
//    Matrix4x4 modelMatrix = _modelMatrix;
//    float r = 5.0f; // fixed horizontal distance
//    Compute camera position in XZ - plane based on _yaw,
//                             and use _verticalOffset for the Y coordinate.
//            float camX = r * MathF.Sin(_yaw);
//    float camY = _verticalOffset;
//    float camZ = r * MathF.Cos(_yaw);
//    Vector3 cameraPosition = new Vector3(camX, camY, camZ);
//    Matrix4x4 viewMatrix = Matrix4x4.CreateLookAt(cameraPosition, Vector3.Zero, Vector3.UnitY);
//    float aspect = _window.Width / (float)_window.Height;
//    Matrix4x4 projectionMatrix = Matrix4x4.CreatePerspectiveFieldOfView(MathF.PI / 4, aspect, 0.1f, 100f);
//    Matrix4x4[] mvpMatrices = new Matrix4x4[] { modelMatrix, viewMatrix, projectionMatrix };
//    _graphicsDevice.UpdateBuffer(_mvpBuffer, 0, mvpMatrices);
//}

//private static void Draw()
//{
//    UpdateMVP();
//    _commandList.Begin();
//    _commandList.SetFramebuffer(_graphicsDevice.SwapchainFramebuffer);
//    _commandList.ClearColorTarget(0, RgbaFloat.Black);
//    _commandList.SetPipeline(_pipeline);
//    _commandList.SetGraphicsResourceSet(0, _mvpResourceSet);
//    _commandList.SetVertexBuffer(0, _vertexBuffer);
//    _commandList.SetIndexBuffer(_indexBuffer, IndexFormat.UInt16);
//    _commandList.DrawIndexed(
//        indexCount: (uint)(_indexBuffer.SizeInBytes / sizeof(ushort)),
//        instanceCount: 1,
//        indexStart: 0,
//        vertexOffset: 0,
//        instanceStart: 0);
//    _commandList.End();
//    _graphicsDevice.SubmitCommands(_commandList);
//    _graphicsDevice.SwapBuffers();
//}

//private static void DisposeResources()
//{
//    _framebuffer.Dispose();
//    _pipeline.Dispose();
//    foreach (Shader shader in _shaders)
//    {
//        shader.Dispose();
//    }
//    _commandList.Dispose();
//    _vertexBuffer.Dispose();
//    _indexBuffer.Dispose();
//    _mvpBuffer.Dispose();
//    _mvpResourceSet.Dispose();
//    _mvpLayout.Dispose();
//    _graphicsDevice.Dispose();
//}

//private static (VertexPositionNormal[], ushort[]) LoadSTL(string path)
//{
//    var vertices = new System.Collections.Generic.List<VertexPositionNormal>();
//    var indices = new System.Collections.Generic.List<ushort>();
//    using (BinaryReader reader = new BinaryReader(File.OpenRead(path)))
//    {
//        reader.ReadBytes(80); // Skip STL header.
//        int triangleCount = reader.ReadInt32();
//        for (int i = 0; i < triangleCount; i++)
//        {
//            Vector3 normal = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
//            for (int j = 0; j < 3; j++)
//            {
//                Vector3 position = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
//                vertices.Add(new VertexPositionNormal(position, normal));
//                indices.Add((ushort)(vertices.Count - 1));
//            }
//            reader.ReadBytes(2); // Skip attribute byte count.
//        }
//    }
//    return (vertices.ToArray(), indices.ToArray());
//}
//    }

//    struct VertexPositionNormal
//{
//    public const uint SizeInBytes = 24;
//    public Vector3 Position;
//    public Vector3 Normal;
//    public VertexPositionNormal(Vector3 position, Vector3 normal)
//    {
//        Position = position;
//        Normal = normal;
//    }
//}
//}



